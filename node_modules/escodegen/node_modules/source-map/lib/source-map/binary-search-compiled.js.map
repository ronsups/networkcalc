{"version":3,"sources":["binary-search.js"],"names":[],"mappings":";;;;;;;;AAMA,IAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,MAAI,SAAS,QAAQ,UAAR,EAAoB,MAApB,EAA4B,OAA5B,CAAb;AACH;AACD,OAAO,UAAU,OAAV,EAAmB,OAAnB,EAA4B,MAA5B,EAAoC;;;;;;;;;;;AAWzC,WAAS,eAAT,CAAyB,IAAzB,EAA+B,KAA/B,EAAsC,OAAtC,EAA+C,SAA/C,EAA0D,QAA1D,EAAoE;;;;;;;;;;;AAWlE,QAAI,MAAM,KAAK,KAAL,CAAW,CAAC,QAAQ,IAAT,IAAiB,CAA5B,IAAiC,IAA3C;AACA,QAAI,MAAM,SAAS,OAAT,EAAkB,UAAU,GAAV,CAAlB,EAAkC,IAAlC,CAAV;AACA,QAAI,QAAQ,CAAZ,EAAe;;AAEb,aAAO,GAAP;AACD,KAHD,MAIK,IAAI,MAAM,CAAV,EAAa;;AAEhB,UAAI,QAAQ,GAAR,GAAc,CAAlB,EAAqB;;AAEnB,eAAO,gBAAgB,GAAhB,EAAqB,KAArB,EAA4B,OAA5B,EAAqC,SAArC,EAAgD,QAAhD,CAAP;AACD;;;AAGD,aAAO,GAAP;AACD,KATI,MAUA;;AAEH,UAAI,MAAM,IAAN,GAAa,CAAjB,EAAoB;;AAElB,eAAO,gBAAgB,IAAhB,EAAsB,GAAtB,EAA2B,OAA3B,EAAoC,SAApC,EAA+C,QAA/C,CAAP;AACD;;;AAGD,aAAO,OAAO,CAAP,GAAW,CAAC,CAAZ,GAAgB,IAAvB;AACD;AACF;;;;;;;;;;;;;;;AAeD,UAAQ,MAAR,GAAiB,SAAS,MAAT,CAAgB,OAAhB,EAAyB,SAAzB,EAAoC,QAApC,EAA8C;AAC7D,QAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,aAAO,CAAC,CAAR;AACD;AACD,WAAO,gBAAgB,CAAC,CAAjB,EAAoB,UAAU,MAA9B,EAAsC,OAAtC,EAA+C,SAA/C,EAA0D,QAA1D,CAAP;AACD,GALD;AAOD,CAtED","file":"binary-search-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next closest element that is less than that element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element which is less than the one we are searching for, so we\n    //      return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // aHaystack[mid] is greater than our needle.\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n      }\n      // We did not find an exact match, return the next closest one\n      // (termination case 2).\n      return mid;\n    }\n    else {\n      // aHaystack[mid] is less than our needle.\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (2) or (3) and return the appropriate thing.\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of next lowest value checked if there is no exact hit. This is\n   * because mappings between original and generated line/col pairs are single\n   * points, and there is an implicit region between each of them, so a miss\n   * just means that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare) {\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)\n  };\n\n});\n"]}