{"version":3,"sources":["expression.js"],"names":[],"mappings":"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","file":"expression-compiled.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {reservedWords} from \"./identifier\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6) return\n  let key = prop.key, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let kind = prop.kind || \"init\", other\n  if (has(propHash, name)) {\n    other = propHash[name]\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raise(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refShorthandDefaultPos, afterLeftParse) {\n  if (this.type == tt._yield && this.inGenerator) return this.parseYield()\n\n  let failOnShorthandAssign\n  if (!refShorthandDefaultPos) {\n    refShorthandDefaultPos = {start: 0}\n    failOnShorthandAssign = true\n  } else {\n    failOnShorthandAssign = false\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refShorthandDefaultPos)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refShorthandDefaultPos.start = 0 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (Array.isArray(leftStartPos)){\n    if (this.options.locations && noIn === undefined) {\n      // shift arguments to left by one\n      noIn = minPrec\n      minPrec = leftStartLoc\n      // flatten leftStartPos\n      leftStartLoc = leftStartPos[1]\n      leftStartPos = leftStartPos[0]\n    }\n  }\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let node = this.startNodeAt(leftStartPos, leftStartLoc)\n      node.left = left\n      node.operator = this.value\n      let op = this.type\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn)\n      this.finishNode(node, (op === tt.logicalOR || op === tt.logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\")\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refShorthandDefaultPos) {\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary()\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raise(node.start, \"Deleting local variable in strict mode\")\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprSubscripts(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  while (this.type.postfix && !this.canInsertSemicolon()) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.prefix = false\n    node.argument = expr\n    this.checkLVal(expr)\n    this.next()\n    expr = this.finishNode(node, \"UpdateExpression\")\n  }\n  return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  return this.parseSubscripts(expr, startPos, startLoc)\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  if (Array.isArray(startPos)){\n    if (this.options.locations && noCalls === undefined) {\n      // shift arguments to left by one\n      noCalls = startLoc\n      // flatten startPos\n      startLoc = startPos[1]\n      startPos = startPos[0]\n    }\n  }\n  for (;;) {\n    if (this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseIdent(true)\n      node.computed = false\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (this.eat(tt.bracketL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseExpression()\n      node.computed = true\n      this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = this.parseExprList(tt.parenR, false)\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refShorthandDefaultPos) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._this:\n  case tt._super:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt._yield:\n    if (this.inGenerator) this.unexpected()\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression(canBeArrow)\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    // check whether this is array comprehension or regular array\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(node, false)\n    }\n    node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refShorthandDefaultPos)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true)\n    }\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true\n    let refShorthandDefaultPos = {start: 0}, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      if (innerParenStart) this.unexpected(innerParenStart)\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument\n// to be a `[]` or dot subscript expression, but not a call — at\n// least, not without wrapping it in parentheses. Thus, it uses the\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raise(node.property.start, \"The only valid meta property for new is new.target\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refShorthandDefaultPos) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refShorthandDefaultPos) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {\n  if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos)\n      prop.kind = \"init\"\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected()\n      prop.kind = \"init\"\n      prop.method = true\n      prop.value = this.parseMethod(isGenerator)\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type != tt.comma && this.type != tt.braceR)) {\n      if (isGenerator || isPattern) this.unexpected()\n      prop.kind = prop.key.name\n      this.parsePropertyName(prop)\n      prop.value = this.parseMethod(false)\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      prop.kind = \"init\"\n      if (isPattern) {\n        if (this.isKeyword(prop.key.name) ||\n            (this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name))) ||\n            (!this.options.allowReserved && this.isReservedWord(prop.key.name)))\n          this.raise(prop.key.start, \"Binding \" + prop.key.name)\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else if (this.type === tt.eq && refShorthandDefaultPos) {\n        if (!refShorthandDefaultPos.start)\n          refShorthandDefaultPos.start = this.start\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else {\n        prop.value = prop.key\n      }\n      prop.shorthand = true\n    } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = (this.type === tt.num || this.type === tt.string) ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode()\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  let allowExpressionBody\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator\n    allowExpressionBody = true\n  } else {\n    allowExpressionBody = false\n  }\n  this.parseFunctionBody(node, allowExpressionBody)\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, allowExpression) {\n  let isExpression = allowExpression && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldInGen = this.inGenerator, oldLabels = this.labels\n    this.inFunction = true; this.inGenerator = node.generator; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.inGenerator = oldInGen; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    let nameHash = {}, oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    for (let i = 0; i < node.params.length; i++)\n      this.checkLVal(node.params[i], true, nameHash)\n    this.strict = oldStrict\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else {\n      if (this.type === tt.ellipsis)\n        elts.push(this.parseSpread(refShorthandDefaultPos))\n      else\n        elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos))\n    }\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal &&\n        ((!this.options.allowReserved && this.isReservedWord(this.value)) ||\n         (this.strict && reservedWords.strict(this.value)) &&\n         (this.options.ecmaVersion >= 6 ||\n          this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1)))\n      this.raise(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\n// Parses array and generator comprehensions.\n\npp.parseComprehension = function(node, isGenerator) {\n  node.blocks = []\n  while (this.type === tt._for) {\n    let block = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    block.left = this.parseBindingAtom()\n    this.checkLVal(block.left, true)\n    this.expectContextual(\"of\")\n    block.right = this.parseExpression()\n    this.expect(tt.parenR)\n    node.blocks.push(this.finishNode(block, \"ComprehensionBlock\"))\n  }\n  node.filter = this.eat(tt._if) ? this.parseParenExpression() : null\n  node.body = this.parseExpression()\n  this.expect(isGenerator ? tt.parenR : tt.bracketR)\n  node.generator = isGenerator\n  return this.finishNode(node, \"ComprehensionExpression\")\n}\n"]}