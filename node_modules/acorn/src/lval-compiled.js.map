{"version":3,"sources":["lval.js"],"names":[],"mappings":"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","file":"lval-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {reservedWords} from \"./identifier\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function(node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"AssignmentPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (let i = 0; i < node.properties.length; i++) {\n        let prop = node.properties[i]\n        if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n      }\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function(exprList, isBinding) {\n  let end = exprList.length\n  if (end) {\n    let last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      let arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n  }\n  for (let i = 0; i < end; i++) {\n    let elt = exprList[i]\n    if (elt) this.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp.parseSpread = function(refShorthandDefaultPos) {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(refShorthandDefaultPos)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp.parseRest = function() {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    let node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this.expect(tt.comma)\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === tt.ellipsis) {\n      let rest = this.parseRest()\n      this.parseBindingListItem(rest)\n      elts.push(rest)\n      this.expect(close)\n      break\n    } else {\n      let elem = this.parseMaybeDefault(this.start, this.startLoc)\n      this.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function(startPos, startLoc, left) {\n  if (Array.isArray(startPos)){\n    if (this.options.locations && noCalls === undefined) {\n      // shift arguments to left by one\n      left = startLoc\n      // flatten startPos\n      startLoc = startPos[1]\n      startPos = startPos[0]\n    }\n  }\n  left = left || this.parseBindingAtom()\n  if (!this.eat(tt.eq)) return left\n  let node = this.startNodeAt(startPos, startLoc)\n  node.operator = \"=\"\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp.checkLVal = function(expr, isBinding, checkClashes) {\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && (reservedWords.strictBind(expr.name) || reservedWords.strict(expr.name)))\n      this.raise(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raise(expr.start, \"Argument name clash in strict mode\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (let i = 0; i < expr.properties.length; i++)\n      this.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (let i = 0; i < expr.elements.length; i++) {\n      let elem = expr.elements[i]\n      if (elem) this.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n"]}