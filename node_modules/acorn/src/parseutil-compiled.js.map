{"version":3,"sources":["parseutil.js"],"names":[],"mappings":";;AAAA;;AACA;;AACA;;AAEA,IAAM,KAAK,cAAO,SAAlB;;;;;;AAMA,GAAG,WAAH,GAAiB,UAAS,IAAT,EAAe;AAC9B,SAAO,KAAK,OAAL,CAAa,WAAb,IAA4B,CAA5B,IAAiC,KAAK,IAAL,KAAc,qBAA/C,IACL,KAAK,UAAL,CAAgB,IAAhB,KAAyB,SADpB,IACiC,KAAK,UAAL,CAAgB,KAAhB,KAA0B,YADlE;AAED,CAHD;;;;;AAQA,GAAG,GAAH,GAAS,UAAS,IAAT,EAAe;AACtB,MAAI,KAAK,IAAL,KAAc,IAAlB,EAAwB;AACtB,SAAK,IAAL;AACA,WAAO,IAAP;AACD,GAHD,MAGO;AACL,WAAO,KAAP;AACD;AACF,CAPD;;;;AAWA,GAAG,YAAH,GAAkB,UAAS,IAAT,EAAe;AAC/B,SAAO,KAAK,IAAL,KAAc,iBAAG,IAAjB,IAAyB,KAAK,KAAL,KAAe,IAA/C;AACD,CAFD;;;;AAMA,GAAG,aAAH,GAAmB,UAAS,IAAT,EAAe;AAChC,SAAO,KAAK,KAAL,KAAe,IAAf,IAAuB,KAAK,GAAL,CAAS,iBAAG,IAAZ,CAA9B;AACD,CAFD;;;;AAMA,GAAG,gBAAH,GAAsB,UAAS,IAAT,EAAe;AACnC,MAAI,CAAC,KAAK,aAAL,CAAmB,IAAnB,CAAL,EAA+B,KAAK,UAAL;AAChC,CAFD;;;;AAMA,GAAG,kBAAH,GAAwB,YAAW;AACjC,SAAO,KAAK,IAAL,KAAc,iBAAG,GAAjB,IACL,KAAK,IAAL,KAAc,iBAAG,MADZ,IAEL,sBAAU,IAAV,CAAe,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAK,UAAtB,EAAkC,KAAK,KAAvC,CAAf,CAFF;AAGD,CAJD;;AAMA,GAAG,eAAH,GAAqB,YAAW;AAC9B,MAAI,KAAK,kBAAL,EAAJ,EAA+B;AAC7B,QAAI,KAAK,OAAL,CAAa,mBAAjB,EACE,KAAK,OAAL,CAAa,mBAAb,CAAiC,KAAK,UAAtC,EAAkD,KAAK,aAAvD;AACF,WAAO,IAAP;AACD;AACF,CAND;;;;;AAWA,GAAG,SAAH,GAAe,YAAW;AACxB,MAAI,CAAC,KAAK,GAAL,CAAS,iBAAG,IAAZ,CAAD,IAAsB,CAAC,KAAK,eAAL,EAA3B,EAAmD,KAAK,UAAL;AACpD,CAFD;;AAIA,GAAG,kBAAH,GAAwB,UAAS,OAAT,EAAkB;AACxC,MAAI,KAAK,IAAL,IAAa,OAAjB,EAA0B;AACxB,QAAI,KAAK,OAAL,CAAa,eAAjB,EACE,KAAK,OAAL,CAAa,eAAb,CAA6B,KAAK,YAAlC,EAAgD,KAAK,eAArD;AACF,SAAK,IAAL;AACA,WAAO,IAAP;AACD;AACF,CAPD;;;;;AAYA,GAAG,MAAH,GAAY,UAAS,IAAT,EAAe;AACzB,OAAK,GAAL,CAAS,IAAT,KAAkB,KAAK,UAAL,EAAlB;AACD,CAFD;;;;AAMA,GAAG,UAAH,GAAgB,UAAS,GAAT,EAAc;AAC5B,OAAK,KAAL,CAAW,OAAO,IAAP,GAAc,GAAd,GAAoB,KAAK,KAApC,EAA2C,kBAA3C;AACD,CAFD","file":"parseutil-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function(stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n    stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\"\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n"]}